package snortcontrol

import (
	"bytes"
	"encoding/binary"
	"io"
	"log"
	"net"
	"time"
)

const (
	SNORT_HDR_VERSION = 1
)

type SnortMessage struct {
	version int16
	msgType int16
	length  int32
}

func Notify(socket string, code, timeout int) {

	var buf bytes.Buffer
	ch := make(chan string)

	msg := SnortMessage{
		version: int16(SNORT_HDR_VERSION),
		msgType: int16(code),
		length:  int32(0),
	}

	c, err := net.Dial("unix", socket)
	if err != nil {
		log.Fatal(err)
	}
	defer c.Close()

	go reader(c, ch)

	binary.Write(&buf, binary.BigEndian, msg)

	if _, err := c.Write(buf.Bytes()); err != nil {
		log.Fatal("Error sending notification to snort")
	}

	select {
	case res := <-ch:
		if len(res) > 0 {
			log.Println(res)
		}
	case <-time.After(time.Duration(timeout) * time.Second):
		log.Fatal("Timeout occurred")
	}
}

func reader(r io.Reader, ch chan string) {
	buf := make([]byte, 1024)

	for {
		n, err := r.Read(buf[:])
		if err != nil {
			return
		}

		msgLengthBytes := buf[4:8]
		msgLength := binary.BigEndian.Uint32(msgLengthBytes)

		if msgLength > 0 {
			msgDataBytes := buf[14:n]
			ch <- "SNORT: " + string(msgDataBytes)
		} else {
			ch <- ""
		}
	}
}
