package snortcontrol

import (
	"bytes"
	"encoding/binary"
	"errors"
	"io"
	"net"
	"time"

	"github.com/Sirupsen/logrus"
)

const (
	SNORT_HDR_VERSION = 1
)

type SnortMessage struct {
	version int16
	msgType int16
	length  int32
}

type Response struct {
	code    int
	message string
}

func Notify(socket net.Conn, code, timeout int) (resCode int, resMessage string, err error) {
	var buf bytes.Buffer

	if socket == nil {
		err = errors.New("Invalid socket")
		return
	}

	ch := make(chan *Response)

	msg := SnortMessage{
		version: int16(SNORT_HDR_VERSION),
		msgType: int16(code),
		length:  int32(0),
	}

	go reader(socket, ch)

	binary.Write(&buf, binary.BigEndian, msg)

	if _, err = socket.Write(buf.Bytes()); err != nil {
		return
	}

	select {
	case res := <-ch:
		resCode = res.code
		resMessage = res.message
		return
	case <-time.After(time.Duration(timeout) * time.Second):
		err = errors.New("Timeout occurred")
		return
	}
}

func reader(r io.Reader, ch chan *Response) {
	buf := make([]byte, 1024)

	n, err := r.Read(buf[:])
	if err != nil {
		logrus.Warn(err)
		return
	}

	res := &Response{}

	msgTypeBytes := buf[2:4]
	res.code = int(binary.BigEndian.Uint16(msgTypeBytes))
	msgLengthBytes := buf[12:14]
	msgLength := binary.BigEndian.Uint16(msgLengthBytes)

	if msgLength > 0 {
		msgDataBytes := buf[14:n]
		res.message = string(msgDataBytes)
	} else {
		res.message = ""
	}

	ch <- res
}
