package client

import (
	"bufio"
	"encoding/json"
	"errors"
	"io"
	"os"
	"strconv"
	"strings"
)

// Release contains information about the score of IP addresses and files previously
// analyzed. Only stores entries with a score greater than minScore
type Release struct {
	Revision    int
	Incremental int

	minScore  float64
	whitelist bool

	hashBlacklist map[string]float64
	ipBlacklist   map[string]float64
	hashWhitelist map[string]float64
	ipWhitelist   map[string]float64

	apiClient *ApiClient
}

// NewRelease creates a new Release object
func NewRelease(minScore float64, whitelist bool, apiClient *ApiClient) (r Release, err error) {
	r = Release{
		Revision:      0,
		Incremental:   0,
		whitelist:     whitelist,
		minScore:      minScore,
		hashBlacklist: make(map[string]float64),
		ipBlacklist:   make(map[string]float64),
		hashWhitelist: make(map[string]float64),
		ipWhitelist:   make(map[string]float64),
		apiClient:     apiClient,
	}

	// Get all data (request total)

	return r
}

// Update updates the information of the release using the API
func (r Release) Update() error {

	// Get current revision using the API

	// Compare with the revision we have stored

	// Perform a request to get the new release using the API

	// Process the data and perform the update

	// Update our version

	return nil
}

// Dump saves the information to a file
func (r Release) Dump() error {

	// Open output files
	hashBlacklistFile, err := os.Create("hashes_blacklist")
	if err != nil {
		return err
	}
	defer hashBlacklistFile.Close()

	ipBlacklistFile, err := os.Create("ips_blacklist")
	if err != nil {
		return err
	}
	defer ipBlacklistFile.Close()

	var hashWhitelistFile *os.File
	if r.whitelist {
		hashWhitelistFile, err = os.Create("hashes_whitelist")
		if err != nil {
			return err
		}
		defer hashWhitelistFile.Close()
	}

	var ipWhitelistFile *os.File
	if r.whitelist {
		ipWhitelistFile, err = os.Create("ips_whitelist")
		if err != nil {
			return err
		}
		defer ipWhitelistFile.Close()
	}

	hashBlacklistWriter := bufio.NewWriter(hashBlacklistFile)
	hashWhitelistWriter := bufio.NewWriter(hashWhitelistFile)
	ipBlacklistWriter := bufio.NewWriter(ipBlacklistFile)
	ipWhitelistWriter := bufio.NewWriter(ipWhitelistFile)

	// Iterate the hashes map and save to a file
	for k, _ := range r.hashBlacklist {
		hashBlacklistWriter.WriteString(k + "\n")
	}

	// Iterate the ip map and save to a file
	for k, _ := range r.ipBlacklist {
		ipBlacklistWriter.WriteString(k + "\n")
	}

	hashBlacklistWriter.Flush()
	ipBlacklistWriter.Flush()

	if r.hashWhitelist != nil {
		// Iterate the hashmap and save to a file
		for k, _ := range r.hashWhitelist {
			hashWhitelistWriter.WriteString(k + "\n")
		}
	}

	if r.ipWhitelist != nil {
		// Iterate the hashmap and save to a file
		for k, _ := range r.ipWhitelist {
			ipWhitelistWriter.WriteString(k + "\n")
		}
	}

	ipWhitelistWriter.Flush()

	return nil
}

// process converts a JSON Array to a hashmap with "hash/IP" as key and "score" as value.
func (r Release) process(body io.ReadCloser) (revision, incremental int, err error) {

	type ParsedBody struct {
		Hash  string  `json:"hash"`
		Score float64 `json:"score"`
		Ip    string  `json:"ip"`
	}

	dec := json.NewDecoder(body)

	// Read open bracket
	_, err = dec.Token()
	if err != nil {
		return
	}

	// Read data key
	var d json.Token
	for d != "data" {
		d, err = dec.Token()
		if err != nil {
			return
		}
	}

	// Read array token
	_, err = dec.Token()
	if err != nil {
		return
	}

	// While the array contains values
	for dec.More() {

		// Decode an array value
		var parsed ParsedBody
		err = dec.Decode(&parsed)
		if err != nil {
			return
		}

		if len(parsed.Hash) > 0 {
			if parsed.Score >= r.minScore {
				r.hashBlacklist[parsed.Hash] = parsed.Score
				delete(r.hashWhitelist, parsed.Hash)
			} else if r.hashWhitelist != nil {
				r.hashWhitelist[parsed.Hash] = parsed.Score
				delete(r.hashBlacklist, parsed.Hash)
			}
		}

		if len(parsed.Ip) > 0 {
			if parsed.Score >= r.minScore {
				r.ipBlacklist[parsed.Ip] = parsed.Score
				delete(r.ipWhitelist, parsed.Hash)
			} else if r.ipWhitelist != nil {
				r.ipWhitelist[parsed.Ip] = parsed.Score
				delete(r.ipBlacklist, parsed.Hash)
			}
		}
	}

	// Read closing array
	d, err = dec.Token()
	if err != nil {
		return
	}

	// Check last release
	d, err = dec.Token()
	if d == "last_release" {
		var strVersion string
		dec.Decode(&strVersion)

		version := strings.Split(strVersion, ".")

		revision, err = strconv.Atoi(version[0])
		if err != nil {
			return
		}
		incremental, err = strconv.Atoi(version[1])
		if err != nil {
			return
		}
	}

	return
}
