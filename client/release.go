package client

import (
	"bufio"
	"encoding/json"
	"errors"
	"io"
	"os"
	"strconv"
	"strings"
)

// Release contains information about the score of IP addresses and files previously
// analyzed. Only stores entries with a score greater than minScore unless
// "whitelist" flag is set to "true"
type Release struct {
	Revision    int
	Incremental int

	minScore  float64
	whitelist bool

	hashBlacklist map[string]float64
	ipBlacklist   map[string]float64
	hashWhitelist map[string]float64
	ipWhitelist   map[string]float64

	apiClient ApiClient
}

// NewRelease creates a new Release object
func NewRelease(minScore float64, whitelist bool, apiClient ApiClient) Release {
	r := Release{
		Revision:      0,
		Incremental:   0,
		whitelist:     whitelist,
		minScore:      minScore,
		hashBlacklist: make(map[string]float64),
		ipBlacklist:   make(map[string]float64),
		hashWhitelist: make(map[string]float64),
		ipWhitelist:   make(map[string]float64),
		apiClient:     apiClient,
	}

	return r
}

// Init gets the Total and then the Incremental if necessary
func (r *Release) Init() (err error) {

	// Get TOTAL and obtain the last release
	total, err := r.apiClient.GetTotal()
	if err != nil {
		err = errors.New("Error getting TOTAL: " + err.Error())
		return
	}
	defer total.Close()

	revision, incremental, err := r.process(total, false)
	if err != nil {
		err = errors.New("Error processing TOTAL: " + err.Error())
		return
	}

	if incremental > 0 {

		// Get INCREMENTAL
		delta, err := r.apiClient.GetIncremental(revision, incremental)
		if err != nil {
			err = errors.New("Error getting INCREMENTAL: " + err.Error())
			return err
		}
		defer delta.Close()

		if _, _, err := r.process(delta, true); err != nil {
			err = errors.New("Error processing INCREMENTAL: " + err.Error())
			return err
		}
	}

	r.Revision = revision
	r.Incremental = incremental

	return
}

// Update checks the current version and updates the local information of the
// release if necessary
func (r *Release) Update() error {

	revision, incremental, err := r.apiClient.GetCurrentRelease()
	if err != nil {
		return errors.New("Error getting current release: " + err.Error())
	}

	if r.Revision != revision {
		// Mayor update, discard all the data we have

		// Get TOTAL and obtain the last release
		total, err := r.apiClient.GetTotal()
		if err != nil {
			return errors.New("Error getting TOTAL: " + err.Error())
		}
		defer total.Close()

		revision, incremental, err := r.process(total, false)
		if err != nil {
			return errors.New("Error processing TOTAL: " + err.Error())
		}

		r.Revision = revision
		r.Incremental = 0

		// Get INCREMENTAL
		delta, err := r.apiClient.GetIncremental(revision, incremental)
		if err != nil {
			return errors.New("Error getting INCREMENTAL: " + err.Error())
		}
		defer delta.Close()

		if _, _, err := r.process(delta, true); err != nil {
			return errors.New("Error processing INCREMENTAL: " + err.Error())
		}

		r.Incremental = incremental

	} else if r.Incremental != incremental {
		// Minor update

		// Get INCREMENTAL
		delta, err := r.apiClient.GetIncremental(revision, incremental)
		if err != nil {
			return errors.New("Error getting INCREMENTAL: " + err.Error())
		}
		defer delta.Close()

		if _, _, err := r.process(delta, true); err != nil {
			return errors.New("Error processing INCREMENTAL: " + err.Error())
		}

		r.Incremental = incremental
	}

	return err
}

// Dump saves the information to a file
func (r Release) Dump() error {

	// Open output files
	hashBlacklistFile, err := os.Create("hashes_blacklist")
	if err != nil {
		return err
	}
	defer hashBlacklistFile.Close()

	ipBlacklistFile, err := os.Create("ips_blacklist")
	if err != nil {
		return err
	}
	defer ipBlacklistFile.Close()

	var hashWhitelistFile *os.File
	if r.whitelist {
		hashWhitelistFile, err = os.Create("hashes_whitelist")
		if err != nil {
			return err
		}
		defer hashWhitelistFile.Close()
	}

	var ipWhitelistFile *os.File
	if r.whitelist {
		ipWhitelistFile, err = os.Create("ips_whitelist")
		if err != nil {
			return err
		}
		defer ipWhitelistFile.Close()
	}

	hashBlacklistWriter := bufio.NewWriter(hashBlacklistFile)
	hashWhitelistWriter := bufio.NewWriter(hashWhitelistFile)
	ipBlacklistWriter := bufio.NewWriter(ipBlacklistFile)
	ipWhitelistWriter := bufio.NewWriter(ipWhitelistFile)

	// Iterate the hashes map and save to a file
	for k, _ := range r.hashBlacklist {
		if _, err := hashBlacklistWriter.WriteString(k + "\n"); err != nil {
			return err
		}
	}
	if err := hashBlacklistWriter.Flush(); err != nil {
		return err
	}

	// Iterate the ip map and save to a file
	for k, _ := range r.ipBlacklist {
		if _, err := ipBlacklistWriter.WriteString(k + "\n"); err != nil {
			return err
		}
	}
	if err := ipBlacklistWriter.Flush(); err != nil {
		return err
	}

	if r.whitelist {
		// Iterate the hashmap and save to a file
		for k, _ := range r.hashWhitelist {
			if _, err := hashWhitelistWriter.WriteString(k + "\n"); err != nil {
				return err
			}
		}
	}
	if err := hashWhitelistWriter.Flush(); err != nil {
		return err
	}

	if r.whitelist {
		// Iterate the hashmap and save to a file
		for k, _ := range r.ipWhitelist {
			if _, err := ipWhitelistWriter.WriteString(k + "\n"); err != nil {
				return err
			}
		}
	}
	if err := ipWhitelistWriter.Flush(); err != nil {
		return err
	}

	return nil
}

// process converts a JSON Array to a hashmap with "hash/IP" as key and "score" as value.
func (r *Release) process(body io.ReadCloser, copyMap bool) (revision, incremental int, err error) {
	type ParsedBody struct {
		Hash  string  `json:"hash"`
		Score float64 `json:"score"`
		Ip    string  `json:"ip"`
	}

	// Make a local copy of the map

	ipBlacklist := make(map[string]float64)
	ipWhitelist := make(map[string]float64)
	hashBlacklist := make(map[string]float64)
	hashWhitelist := make(map[string]float64)

	if copyMap {
		for k, v := range r.ipBlacklist {
			ipBlacklist[k] = v
		}

		for k, v := range r.ipWhitelist {
			ipWhitelist[k] = v
		}

		for k, v := range r.hashBlacklist {
			hashBlacklist[k] = v
		}

		for k, v := range r.hashWhitelist {
			hashWhitelist[k] = v
		}
	}

	// Let the parsing begin!
	dec := json.NewDecoder(body)

	// Read open bracket
	if _, err = dec.Token(); err != nil {
		return
	}

	// Read data key
	var d json.Token
	for d != "data" {
		d, err = dec.Token()
		if err != nil {
			return
		}
	}

	// Read array token
	if _, err = dec.Token(); err != nil {
		return
	}

	// While the array contains values
	for dec.More() {

		// Decode an array value
		var parsed ParsedBody
		if err = dec.Decode(&parsed); err != nil {
			return
		}

		if len(parsed.Hash) > 0 {
			if parsed.Score >= r.minScore {
				hashBlacklist[parsed.Hash] = parsed.Score
				delete(hashWhitelist, parsed.Hash)
			} else if hashWhitelist != nil {
				hashWhitelist[parsed.Hash] = parsed.Score
				delete(hashBlacklist, parsed.Hash)
			}
		}

		if len(parsed.Ip) > 0 {
			if parsed.Score >= r.minScore {
				ipBlacklist[parsed.Ip] = parsed.Score
				delete(ipWhitelist, parsed.Ip)
			} else if ipWhitelist != nil {
				ipWhitelist[parsed.Ip] = parsed.Score
				delete(ipBlacklist, parsed.Ip)
			}
		}
	}

	// Read closing array
	if _, err = dec.Token(); err != nil {
		return
	}

	// Check last release
	d, err = dec.Token()
	if err != nil {
		return
	}

	if d == "last_release" {
		var strVersion string
		if err = dec.Decode(&strVersion); err != nil {
			return
		}
		version := strings.Split(strVersion, ".")

		revision, err = strconv.Atoi(version[0])
		if err != nil {
			return
		}

		incremental, err = strconv.Atoi(version[1])
		if err != nil {
			return
		}
	}

	// Parse JSON untill the end, we don't want invalid JSONs
	_, err = dec.Token()
	if err != nil {
		return
	}

	// If there are no errors then we commit changes on the map
	r.hashBlacklist = hashBlacklist
	r.hashWhitelist = hashWhitelist
	r.ipBlacklist = ipBlacklist
	r.ipWhitelist = ipWhitelist

	return
}
