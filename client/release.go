package client

import (
	"bufio"
	"encoding/json"
	"errors"
	"io"
	"os"
	"strconv"
	"strings"
)

// Release contains information about the score of IP addresses and files previously
// analyzed. Only stores entries with a score greater than minScore unless
// "whitelist" flag is set to "true"
type Release struct {
	Revision    int
	Incremental int

	minScore  float64
	whitelist bool

	hashBlacklist map[string]float64
	ipBlacklist   map[string]float64
	hashWhitelist map[string]float64
	ipWhitelist   map[string]float64

	apiClient ApiClient
}

// NewRelease creates a new Release object
func NewRelease(minScore float64, whitelist bool, apiClient ApiClient) Release {
	r := Release{
		Revision:      0,
		Incremental:   0,
		whitelist:     whitelist,
		minScore:      minScore,
		hashBlacklist: make(map[string]float64),
		ipBlacklist:   make(map[string]float64),
		hashWhitelist: make(map[string]float64),
		ipWhitelist:   make(map[string]float64),
		apiClient:     apiClient,
	}

	return r
}

// Init gets the Total and then the Incremental if necessary
func (r *Release) Init() (err error) {

	// Get TOTAL and obtain the last release
	total, err := r.apiClient.GetTotal()
	if err != nil {
		err = errors.New("Error getting TOTAL: " + err.Error())
		return
	}
	defer total.Close()

	revision, incremental, err := r.process(total)
	if err != nil {
		err = errors.New("Error processing TOTAL: " + err.Error())
		return
	}

	if incremental > 0 {

		// Get INCREMENTAL
		delta, err := r.apiClient.GetIncremental(revision, incremental)
		if err != nil {
			err = errors.New("Error getting INCREMENTAL: " + err.Error())
			return err
		}
		defer delta.Close()

		if _, _, err := r.process(delta); err != nil {
			err = errors.New("Error processing INCREMENTAL: " + err.Error())
			return err
		}
	}

	r.Revision = revision
	r.Incremental = incremental

	return
}

// Update checks the current version and updates the local information of the
// release if necessary
func (r *Release) Update() (err error) {

	revision, incremental, err := r.apiClient.GetCurrentRelease()

	if r.Revision != revision {
		// Mayor update

		// Get TOTAL and obtain the last release
		total, err := r.apiClient.GetTotal()
		if err != nil {
			err = errors.New("Error getting TOTAL: " + err.Error())
			return err
		}
		defer total.Close()

		revision, incremental, err := r.process(total)
		if err != nil {
			err = errors.New("Error processing TOTAL: " + err.Error())
			return err
		}

		// Get INCREMENTAL
		delta, err := r.apiClient.GetIncremental(revision, incremental)
		if err != nil {
			err = errors.New("Error getting INCREMENTAL: " + err.Error())
			return err
		}
		defer delta.Close()

		if _, _, err := r.process(delta); err != nil {
			err = errors.New("Error processing INCREMENTAL: " + err.Error())
			return err
		}

		r.Revision = revision
		r.Incremental = incremental

	} else if r.Incremental != incremental {
		// Minor update

		// Get INCREMENTAL
		delta, err := r.apiClient.GetIncremental(revision, incremental)
		if err != nil {
			err = errors.New("Error getting INCREMENTAL: " + err.Error())
			return err
		}
		defer delta.Close()

		if _, _, err := r.process(delta); err != nil {
			err = errors.New("Error processing INCREMENTAL: " + err.Error())
			return err
		}

		r.Incremental = incremental
	}

	return
}

// Dump saves the information to a file
func (r Release) Dump() error {

	// Open output files
	hashBlacklistFile, err := os.Create("hashes_blacklist")
	if err != nil {
		return err
	}
	defer hashBlacklistFile.Close()

	ipBlacklistFile, err := os.Create("ips_blacklist")
	if err != nil {
		return err
	}
	defer ipBlacklistFile.Close()

	var hashWhitelistFile *os.File
	if r.whitelist {
		hashWhitelistFile, err = os.Create("hashes_whitelist")
		if err != nil {
			return err
		}
		defer hashWhitelistFile.Close()
	}

	var ipWhitelistFile *os.File
	if r.whitelist {
		ipWhitelistFile, err = os.Create("ips_whitelist")
		if err != nil {
			return err
		}
		defer ipWhitelistFile.Close()
	}

	hashBlacklistWriter := bufio.NewWriter(hashBlacklistFile)
	hashWhitelistWriter := bufio.NewWriter(hashWhitelistFile)
	ipBlacklistWriter := bufio.NewWriter(ipBlacklistFile)
	ipWhitelistWriter := bufio.NewWriter(ipWhitelistFile)

	// Iterate the hashes map and save to a file
	for k, _ := range r.hashBlacklist {
		hashBlacklistWriter.WriteString(k + "\n")
	}
	hashBlacklistWriter.Flush()

	// Iterate the ip map and save to a file
	for k, _ := range r.ipBlacklist {
		ipBlacklistWriter.WriteString(k + "\n")
	}
	ipBlacklistWriter.Flush()

	if r.whitelist {
		// Iterate the hashmap and save to a file
		for k, _ := range r.hashWhitelist {
			hashWhitelistWriter.WriteString(k + "\n")
		}
	}
	hashWhitelistWriter.Flush()

	if r.whitelist {
		// Iterate the hashmap and save to a file
		for k, _ := range r.ipWhitelist {
			ipWhitelistWriter.WriteString(k + "\n")
		}
	}
	ipWhitelistWriter.Flush()

	return nil
}

// process converts a JSON Array to a hashmap with "hash/IP" as key and "score" as value.
func (r Release) process(body io.ReadCloser) (revision, incremental int, err error) {

	type ParsedBody struct {
		Hash  string  `json:"hash"`
		Score float64 `json:"score"`
		Ip    string  `json:"ip"`
	}

	dec := json.NewDecoder(body)

	// Read open bracket
	if _, err = dec.Token(); err != nil {
		return
	}

	// Read data key
	var d json.Token
	for d != "data" {
		d, err = dec.Token()
		if err != nil {
			return
		}
	}

	// Read array token
	if _, err = dec.Token(); err != nil {
		return
	}

	// While the array contains values
	for dec.More() {

		// Decode an array value
		var parsed ParsedBody
		if err = dec.Decode(&parsed); err != nil {
			return
		}

		if len(parsed.Hash) > 0 {
			if parsed.Score >= r.minScore {
				r.hashBlacklist[parsed.Hash] = parsed.Score
				delete(r.hashWhitelist, parsed.Hash)
			} else if r.hashWhitelist != nil {
				r.hashWhitelist[parsed.Hash] = parsed.Score
				delete(r.hashBlacklist, parsed.Hash)
			} else {
				delete(r.hashBlacklist, parsed.Hash)

			}
		}

		if len(parsed.Ip) > 0 {
			if parsed.Score >= r.minScore {
				r.ipBlacklist[parsed.Ip] = parsed.Score
				delete(r.ipWhitelist, parsed.Ip)
			} else if r.ipWhitelist != nil {
				r.ipWhitelist[parsed.Ip] = parsed.Score
				delete(r.ipBlacklist, parsed.Ip)
			} else {
				delete(r.ipBlacklist, parsed.Ip)
			}
		}
	}

	// Read closing array
	if _, err = dec.Token(); err != nil {
		return
	}

	// Check last release
	d, err = dec.Token()
	if err != nil {
		return
	}

	if d == "last_release" {
		var strVersion string
		dec.Decode(&strVersion)
		version := strings.Split(strVersion, ".")

		revision, err = strconv.Atoi(version[0])
		if err != nil {
			return
		}

		incremental, err = strconv.Atoi(version[1])
		if err != nil {
			return
		}
	}

	return
}
