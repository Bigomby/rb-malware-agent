package main

import (
	"flag"
	"os"
	"time"

	"redborder/malware-agent/client"
)

// Options stores the configuration of the application
type Options struct {
	url       string
	whitelist bool
	minScore  float64
}

// getopts parses arguments from stdout into a Options struct
func getopts() Options {

	var opts Options

	urlFlag := flag.String("url", "", "API url")
	minScoreFlag := flag.Float64("min_score", 50, "Min score to add to the blacklist")
	whitelistFlag := flag.Bool("whitelist", false, "File to add entries with score < min_score")

	flag.Parse()

	if len(*urlFlag) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	opts.minScore = *minScoreFlag
	opts.whitelist = *whitelistFlag

	opts.url = *urlFlag
	return opts
}

func notify() {

}

func main() {
	// opts := getopts()

	apiClient := client.NewApiClient("http://10.0.150.77:7777/reputation/v1/malware")
	release := client.NewRelease(50, false, &apiClient)

	for {
		select {
		case <-time.After(10 * time.Second):
			release.Update()
			release.Dump()
			notify()
		}
	}
}

// func main() {
// 	getopts()

// 	var err error

// 	var lists Lists
// 	lists.HashBlacklist = make(map[string]float64)
// 	lists.IpBlacklist = make(map[string]float64)

// 	if opts.whitelist {
// 		lists.HashWhitelist = make(map[string]float64)
// 		lists.IpWhitelist = make(map[string]float64)
// 	}

// 	currentRevision := 0
// 	currentIncremental := 0
// 	newRevision := 0
// 	newIncremental := 0

// 	// Get TOTAL list
// 	log.Printf("Obtaining current revision...\n")
// 	newRevision, newIncremental, err = requestTotal(lists)
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// 	currentRevision = newRevision
// 	log.Printf("Current revision: %d\n", currentRevision)

// 	// If there are incrementals available, get the latest one
// 	if newIncremental > 0 {
// 		log.Printf("Obtaining new incremental: %d\n", newIncremental)
// 		err = requestIncremental(lists, newIncremental)
// 		if err != nil {
// 			log.Println(err)
// 		} else {
// 			currentIncremental = newIncremental
// 		}
// 	}
// 	log.Printf("Current incremental: %d\n", currentIncremental)

// 	for true {
// 		select {
// 		case <-time.After(10 * time.Second):

// 			// Check new releases
// 			newRevision, newIncremental = getCurrentVersion()

// 			if newRevision != currentRevision {

// 				// If a mayor release has been published, get it
// 				log.Printf("Updating revision to: %d\n", newRevision)
// 				newRevision, newIncremental, err = requestTotal(lists)

// 				if err != nil {
// 					log.Println(err)
// 				} else {
// 					currentRevision = newRevision
// 					log.Printf("Obtained revision: %s\n", currentRevision)

// 					// And get the latest incremental
// 					if newIncremental > 0 {
// 						log.Printf("Obtaining new incremental: %d\n", newIncremental)
// 						err = requestIncremental(lists, newIncremental)
// 						if err != nil {
// 							log.Println(err)
// 						} else {
// 							currentIncremental = newIncremental
// 						}
// 					}
// 					log.Printf("Current incremental: %d\n", currentIncremental)
// 				}

// 			} else if newIncremental != currentIncremental {
// 				// If a new incremental is available request it
// 				log.Printf("Obtaining new incremental: %d\n", newIncremental)
// 				err = requestIncremental(lists, newIncremental)
// 				if err != nil {
// 					log.Println(err)
// 				} else {
// 					currentIncremental = newIncremental
// 				}
// 				log.Printf("Current incremental: %d\n", currentIncremental)
// 			} else {
// 				log.Printf("Up-to-date at: %d.%d\n", currentRevision, currentIncremental)
// 			}
// 		}
// 	}
// }
