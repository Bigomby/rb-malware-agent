package main

import (
	"flag"
	"net/http"
	"os"
	"runtime"
	"strconv"
	"time"

	"github.com/Sirupsen/logrus"

	"redborder/malware-agent/client"
	"redborder/malware-agent/snortcontrol"
)

const (
	// Snort control codes
	SNORT_IP_RELOAD_CODE   = 1631
	SNORT_HASH_RELOAD_CODE = 1471
	SNORT_MESSAGE_TIMEOUT  = 5000
)

// Options stores the configuration of the application
var (
	url            string
	whitelist      bool
	minScore       float64
	updateInterval int
	socketPath     string
	timeout        int
)

// Used for parsing params
func init() {
	urlFlag := flag.String("url", "", "API url")
	minScoreFlag := flag.Float64("min_score", 50, "Min score to add to the blacklist")
	whitelistFlag := flag.Bool("whitelist", false, "File to add entries with score < min_score")
	updateIntervalFlag := flag.Int("interval", 0, "Interval in seconds between updates")
	unixSockFlag := flag.String("socket_dir", "", "Unix socket control directory")
	timeoutFlag := flag.Int("timeout", 5, "Socket timeout")

	flag.Parse()

	if len(*urlFlag) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	minScore = *minScoreFlag
	whitelist = *whitelistFlag
	updateInterval = *updateIntervalFlag
	url = *urlFlag
	socketPath = *unixSockFlag
	timeout = *timeoutFlag
}

func main() {
	var err error
	httpClient := &http.Client{}
	apiClient := client.NewApiClient(url, httpClient)
	release := client.NewRelease(minScore, whitelist, apiClient)

	if err = release.Init(); err != nil {
		logrus.Fatal(err)
	}

	if err = release.Dump(); err != nil {
		logrus.Fatal(err)
	} else if len(socketPath) > 0 && err != nil {
		notify()
	}

	logrus.Debugf("Local data version: %d.%d\n", release.Revision, release.Incremental)

	if err != nil {

		if updateInterval != 0 {
			for {
				select {
				case <-time.After(time.Duration(updateInterval) * time.Second):
					if err := release.Update(); err != nil {
						logrus.Error(err)
					}
					if err := release.Dump(); err != nil {
						logrus.Error(err)
					} else if len(socketPath) > 0 && err != nil {
						notify()
					}

					logrus.Debugf("Local data version: %d.%d\n", release.Revision, release.Incremental)
					runtime.GC()
				}
			}
		}
	}
}

// notify sends an IP reload notification to snort instance 0 and HASH reload
// notification to all snort instances.
func notify() {
	snortcontrol.Notify(
		socketPath+"instance-0/SNORT.sock",
		SNORT_IP_RELOAD_CODE,
		SNORT_MESSAGE_TIMEOUT,
	)

	i := 0
	for {
		if _, err := os.Stat(socketPath + "/instance-" +
			strconv.FormatInt(int64(i), 10) + "/SNORT.sock"); os.IsNotExist(err) {
			break
		}

		snortcontrol.Notify(
			socketPath+"instance-"+strconv.FormatInt(int64(i), 10)+"/SNORT.sock",
			SNORT_HASH_RELOAD_CODE,
			SNORT_MESSAGE_TIMEOUT,
		)
		i++
	}
}
