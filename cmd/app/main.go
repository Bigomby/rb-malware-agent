package main

import (
	"flag"
	"net"
	"net/http"
	"os"
	"runtime"
	"strconv"
	"time"

	"github.com/Sirupsen/logrus"

	"redborder/malware-agent/client"
	"redborder/malware-agent/snortcontrol"
)

const (
	// Snort control codes
	SNORT_IP_RELOAD_CODE   = 1361
	SNORT_HASH_RELOAD_CODE = 1471
	SNORT_MESSAGE_TIMEOUT  = 5000
)

// Options stores the configuration of the application
var (
	url            string
	outputPath     string
	ipWhitelist    bool
	hashWhitelist  bool
	minScore       float64
	updateInterval int
	socketPath     string
	timeout        int
)

// Used for parsing params
func init() {
	urlFlag := flag.String("url", "", "API url")
	minScoreFlag := flag.Float64("min_score", 50, "Min score to add to the blacklist")
	outputPathFlag := flag.String("output", "", "Path to save the output files")
	ipWhitelistFlag := flag.Bool("ip_whitelist", false, "File to add IPs with score < min_score")
	hashWhitelistFlag := flag.Bool("hash_whitelist", false, "File to add hashes with score < min_score")
	updateIntervalFlag := flag.Int("interval", 0, "Interval in seconds between updates")
	unixSockFlag := flag.String("socket_dir", "", "Unix socket control directory")
	timeoutFlag := flag.Int("timeout", 5, "Socket timeout")
	debugFlag := flag.Bool("debug", false, "Print debug info")

	flag.Parse()

	if len(*urlFlag) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	if len(*outputPathFlag) == 0 {
		flag.Usage()
		os.Exit(1)
	}

	if *debugFlag {
		logrus.SetLevel(logrus.DebugLevel)
	}

	url = *urlFlag
	minScore = *minScoreFlag
	outputPath = *outputPathFlag
	ipWhitelist = *ipWhitelistFlag
	hashWhitelist = *hashWhitelistFlag
	updateInterval = *updateIntervalFlag
	socketPath = *unixSockFlag
	timeout = *timeoutFlag
}

func main() {
	var err error
	httpClient := &http.Client{}
	apiClient := client.NewApiClient(url, httpClient)
	release := client.NewRelease(minScore, ipWhitelist, hashWhitelist, apiClient)

	logrus.Debugf("Initializing")
	if err = release.Init(); err != nil {
		logrus.Error(err)
	} else {

		logrus.Debugf("Saving data to file")
		if err = release.Dump(outputPath); err != nil {
			logrus.Error(err)
		} else if len(socketPath) > 0 && err != nil {
			notify()
		}
		logrus.Infof("Local data version: %d.%d", release.Revision, release.Incremental)
	}

	if updateInterval != 0 {
		for {
			select {
			case <-time.After(time.Duration(updateInterval) * time.Second):
				if err := release.Update(); err != nil {
					logrus.Error(err)
				} else {
					if err := release.Dump(outputPath); err != nil {
						logrus.Error(err)
					} else {
						logrus.Debugf("Local data version: %d.%d\n", release.Revision, release.Incremental)
						if len(socketPath) > 0 && err != nil {
							notify()
						}
					}

					runtime.GC()
				}
			}
		}
	}
}

// notify sends an IP reload notification to snort instance 0 and HASH reload
// notification to all snort instances.
func notify() {
	socket, err := net.Dial("unix", socketPath+"instance-0/SNORT.sock")
	if err != nil {
		logrus.Warn(err)
	}
	defer socket.Close()

	code, message, err := snortcontrol.Notify(
		socket,
		SNORT_IP_RELOAD_CODE,
		SNORT_MESSAGE_TIMEOUT,
	)
	if err != nil {
		logrus.Warn(err)
		return
	}

	if code != 0 {
		logrus.Warn("Snort notify error: " + message)
	}

	i := 0
	for {
		if _, err := os.Stat(socketPath + "/instance-" +
			strconv.FormatInt(int64(i), 10) + "/SNORT.sock"); os.IsNotExist(err) {
			break
		}

		socket, err := net.Dial("unix",
			socketPath+"instance-"+strconv.FormatInt(int64(i), 10)+"/SNORT.sock")
		if err != nil {
			logrus.Warn(err)
		}
		defer socket.Close()

		snortcontrol.Notify(
			socket,
			SNORT_HASH_RELOAD_CODE,
			SNORT_MESSAGE_TIMEOUT,
		)
		i++
	}
}
