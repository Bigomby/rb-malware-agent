package main

import (
	"flag"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strconv"
	"syscall"
	"time"

	"github.com/Sirupsen/logrus"
	"gopkg.in/yaml.v2"

	"redborder/malware-agent/client"
	"redborder/malware-agent/snortcontrol"
)

const (
	// Snort control codes
	SNORT_IP_RELOAD_CODE   = 1361
	SNORT_HASH_RELOAD_CODE = 1471
	SNORT_MESSAGE_TIMEOUT  = 5000
)

type Config struct {
	Url      string  `yaml:"url"`
	MinScore float64 `yaml:"min_score"`

	IpBlacklist   string `yaml:"ip_blacklist"`
	IpWhitelist   string `yaml:"ip_whitelist"`
	HashBlacklist string `yaml:"hash_blacklist"`
	HashWhitelist string `yaml:"hash_whitelist"`

	Interval int `yaml:"interval"`

	SocketPath    string `yaml:"snort_socket_path"`
	SocketTimeout int    `yaml:"snort_socket_timeout"`
}

// Options stores the configuration of the application
var (
	configFileName string
	config         Config
	listPath       *client.ListsPath
)

// Used for parsing params
func init() {
	debug := flag.Bool("debug", false, "Print debug info")
	configFileFlag := flag.String("config", "", "Config file")
	flag.Parse()

	if *debug {
		logrus.SetLevel(logrus.DebugLevel)
	}

	configFileName = *configFileFlag

	if len(configFileName) == 0 {
		flag.Usage()
		os.Exit(0)
	}

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}

	if len(config.Url) == 0 {
		logrus.Fatal("No URL provided")
	}

	if config.MinScore == 0 {
		config.MinScore = 50
		logrus.Warning("Min score set to: 50")
	}

	listPath = &client.ListsPath{
		HashBlacklistPath: config.HashBlacklist,
		IpBlacklistPath:   config.IpBlacklist,
		HashWhitelistPath: config.HashWhitelist,
		IpWhitelistPath:   config.IpWhitelist,
	}
}

func main() {
	var err error
	httpClient := &http.Client{}
	apiClient := client.NewApiClient(config.Url, httpClient)
	release := client.NewRelease(config.MinScore, apiClient, listPath)

	logrus.Debugf("Initializing")
	if err = release.Init(); err != nil {
		logrus.Error(err)
	} else {

		logrus.Debugf("Saving data to file")
		if err = release.Dump(); err != nil {
			logrus.Error(err)
		} else if len(config.SocketPath) > 0 && err != nil {
			notify()
		}
	}

	// Keep updating
	if config.Interval != 0 {
		for {
			select {
			case <-time.After(time.Duration(config.Interval) * time.Second):
				logrus.Debugf("Checking new release")

				if err := release.Update(); err != nil {
					logrus.Error(err)
				} else {
					if err := release.Dump(); err != nil {
						logrus.Error(err)
					} else {
						if len(config.SocketPath) > 0 && err != nil {
							notify()
						}
					}

					runtime.GC()
				}
			}
		}
	}
}

// notify sends an IP reload notification to snort instance 0 and HASH reload
// notification to all snort instances.
func notify() {
	socket, err := net.Dial("unix", config.SocketPath+"instance-0/SNORT.sock")
	if err != nil {
		logrus.Warn(err)
	}
	defer socket.Close()

	code, message, err := snortcontrol.Notify(
		socket,
		SNORT_IP_RELOAD_CODE,
		SNORT_MESSAGE_TIMEOUT,
	)
	if err != nil {
		logrus.Warn(err)
		return
	}

	if code != 0 {
		logrus.Warn("Snort notify error: " + message)
	}

	i := 0
	for {
		if _, err := os.Stat(config.SocketPath + "/instance-" +
			strconv.FormatInt(int64(i), 10) + "/SNORT.sock"); os.IsNotExist(err) {
			break
		}

		socket, err := net.Dial("unix",
			config.SocketPath+"instance-"+strconv.FormatInt(int64(i), 10)+"/SNORT.sock")
		if err != nil {
			logrus.Warn(err)
		}
		defer socket.Close()

		snortcontrol.Notify(
			socket,
			SNORT_HASH_RELOAD_CODE,
			SNORT_MESSAGE_TIMEOUT,
		)
		i++
	}
}

func reload() {
	logrus.Infof("Reloading")

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}
}
