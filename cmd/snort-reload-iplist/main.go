package main

import (
	"bytes"
	"encoding/binary"
	"flag"
	"io"
	"log"
	"net"
	"os"
	"strconv"
	"time"
)

type SnortMessage struct {
	version int16
	msgType int16
	length  int32
}

var (
	socket  string
	timeout int
)

func init() {
	unixSockFlag := flag.String("socket", "", "Unix socket name")
	timeoutFlag := flag.String("timeout", "", "Timeout in milliseconds")

	flag.Parse()

	if unixSockFlag != nil {
		socket = *unixSockFlag
	} else {
		flag.Usage()
		os.Exit(0)
	}
	if timeoutFlag != nil {
		timeout, _ = strconv.Atoi(*timeoutFlag)
	}
}

func main() {

	var buf bytes.Buffer
	ch := make(chan string)

	msg := SnortMessage{
		version: 1,
		msgType: 1361,
		length:  int32(0),
	}

	c, err := net.Dial("unix", socket)
	if err != nil {
		log.Fatal(err)
	}
	defer c.Close()

	go reader(c, ch)

	binary.Write(&buf, binary.BigEndian, msg)

	if _, err := c.Write(buf.Bytes()); err != nil {
		log.Fatal("Error sending notification to snort")
	}

	select {
	case res := <-ch:
		log.Println(res)
	case <-time.After(5 * time.Second):
		log.Fatal("Timeout occurred")
	}
}

func reader(r io.Reader, ch chan string) {
	buf := make([]byte, 1024)

	for {
		n, err := r.Read(buf[:])
		if err != nil {
			return
		}

		msgVersionBytes := buf[0:2]
		msgTypeBytes := buf[2:4]
		msgLengthBytes := buf[4:8]
		msgVersion := binary.BigEndian.Uint16(msgVersionBytes)
		msgType := binary.BigEndian.Uint16(msgTypeBytes)
		msgLength := binary.BigEndian.Uint32(msgLengthBytes)

		if msgLength > 0 {
			msgDataBytes := buf[14:n]
			ch <- "VERSION: " + strconv.Itoa(int(msgVersion)) +
				" - TYPE: " + strconv.Itoa(int(msgType)) +
				" - LENGTH: " + strconv.Itoa(int(msgLength)) +
				" - DATA: " + string(msgDataBytes)
		} else {
			ch <- "VERSION: " + strconv.Itoa(int(msgVersion)) +
				" - TYPE: " + strconv.Itoa(int(msgType)) +
				" - LENGTH: " + strconv.Itoa(int(msgLength))
		}
	}
}
